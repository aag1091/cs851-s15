ECMAScript 6, in short ES6, has been boiling in a copper pot for many years by now and step-by-step, browser vendors come forward to taste the first sips of this mystery soup. So, ES6 is no longer a …ECMAScript 6, in short ES6, has been boiling in a copper pot for many years by now and step-by-step, browser vendors come forward to taste the first sips of this mystery soup. So, ES6 is no longer a theoretic language but already crawled across the doorstep and now lurks under your bed, ready for the nasty, waiting for the right moment to bite.Now, what is this whole ES6 thing? How did it develop and who made it? And why is it now implemented in your favorite browser? And what does it mean for web-security and beyond?This talk will answer these questions and showcase the new language from an attacker's perspective. You will see the new code constructs possible to be executed with ES6, new attack vectors and learn what you can do to tame that beast. Kafkaesque terminology such as expression interpolation, proper tail calls, computed properties, spread parameters, modules and tagged template strings will no longer be surprising you after attending this talk.I'll do a longer review here later, but you should double check some of your slides. An arrow function grabbing access to windows through this is a completely legal call. It's a named function inside the window's scope.4. What's on today's Menu? ● A bit of JavaScript History ● What is JavaScript, where did it come from ● And where is it going? ● A bit more on ECMAScript 6 ● Some of the new bits ● Implemented features ● Not yet implemented features ● ECMAScript 7 Preview ● Security Impact ● How does ES6 change security assumptions ● How can we execute code where we couldn't before ● What else is affected? ● Example Vulnerabilities ● A lot of code examples and practical exploration ● Conclusion & Spyglass5. And what's not to expect? ● Completeness ● We won't cover all ES6 features and novelties ● Just the ones interesting from a security perspective ● Scope: Injections, Sandboxes, Filters and Sanitizers, Parsers, DOM Security ● Explosions ● We have no uber-XSS or one-bug-to-rule-them-all ● We're looking at a new language. Skeptically. ● Deep Dives ● There's many new things in ES6 ● And a lot of those novelties are relevant for us here ● This talk is an excursion to have a look at these ● A deep dive would be the next step, maybe from you?6. JavaScript “Netscape also wanted a lightweight interpreted language that would complement Java by appealing to nonprofessional programmers, like Microsoft's Visual Basic” From http://ghost.jollygoodthemes.com/toffee/the­story­of­javascript/7. History Lesson 1994 ● Mocha/LiveScript released in NetScape 2.0B1 ● Renamed to JavaScript with NetScape 2.0B3 ● Server-Side JavaScript in NetScape Enterprise Server 1996 ● Oracle applied for Trademark “JavaScript” ● JavaScript appears in Internet Explorer 3.0 ● IIS also starts supporting JavaScript that same year ● 1997 ● First Edition of ECMA 262-1 was published ● MS renames their JavaScript to JScript ● Fixes of Y2K bugs in Date() methods ● 2009 ● ECMA 262-5 was finally published ● Followed by ES 5.1 in 2011 ● NodeJS was published ● 2005 ● The E4X beast was released ● ECMA 262-4 never saw the light of the world ● JavaScript 1.6 ● 2000 ● ECMA 262-3 was published ● JavaScript version 1.5 ● Trademark “JavaScript” is granted to Oracle10. From https://developer.mozilla.org/en-US/docs/Archive/Web/Sharp_variables_in_JavaScript11. Impact on Attack Surface? ● Syntax extensions and proprietary features enlarge the attack surface ● Make unexploitable injections exploitable ● Intersecting syntactic relevance ● For example, the hash character (U+0023) ● No syntactic meaning in JavaScript, invalid character ● But introduces sharp variables in JavaScript < 1.8.5 and date objects in VBScript ● So we can do things we are not allowed by language ● And the attack surface grows ● My point? A single character can change a lot ● Often we also see injections into so called “dead zones” ● Areas where we can inject but not execute ● Areas we cannot terminate or break out12. Code Execution Dead Zones ● Imagine you have an injection on a tested website ● But you cannot escape from where you are ● You know that something should work ● But you cannot quite turn it into a goal and execute code ● For instance, an injection into a function declaration ● Like function(a, injection, b){// do stuff} ● Or an injection inside an object property declaration ● Like var a = {injection: "value"}; ● That's often frustrating and cries for additional research ● Time we often do not have ● Legacy features might help here ● If they are still supported ● And if the stars are aligned properly ● A lot of ifs... ● Sometimes you would require a whole new language to make it work ● “Whole new languages” don't happen too often13. Let's however have yet another small excursion into the fascinating, wild and adventurous world of standardization. Much more exciting than actual attacks and crazy code.15. ECMAScript ● ECMAScript standardizes what JScript and JavaScript, Acrobat Script or even Action Script implement ● At least mostly, each implementation has deviations from the specification ● The work on ECMA-262 began already in November 1996 ● Short after Netscape submitted the language draft to ECMA ● Microsoft then added JScript to MSIE 3.0 ● Then... ● ECMAScript 1st Edition in 1997 ● ECMAScript 2nd Edition in 1998 with minor modifications ● ECMAScript 3rd Edition in 1999 ● ECMAScript 4th Edition never saw the light of the world ● ECMAScript 5th Edition released in 2009 ● Now ● ECMAScript 6th Edition / ECMAScript Harmony16. ECMAScript 6 ● The new JavaScript. So to say. “The language for the web” ● Initially announced by Brendan Eich in 2008, a successor for the never-released ECMAScript 4 ● Changes said to be more moderate compared to ES4 (orly?) ● Which should have gotten Packages... ● Planned support for namespaces... ● Early binding and static typing... ● Classes and destructuring assignment etc. etc. ● First drafts published regularly since 2011 ● Expected to be finished in June 2015 ● Currently discussed and documented here ● Es-discuss https://mail.mozilla.org/listinfo/es-discuss ● ES Wiki http://wiki.ecmascript.org/doku.php ● ES6 Plans https://wiki.mozilla.org/ES6_plans ● Lots of news for developers ● But also a lot of sugar for attackers and pentesters17. Security Relevance ● We'll address the features we have found to be security relevant so far. Or will be once implemented. ● This list might grow or shrink, ES6 is still WIP and a moving target ● And here they are ● A: Arrow Functions ● B: Generator Functions ● C: Unicode Escapes ● D: Template Strings ● E: Symbols ● F: Modules ● G: Reflection ● H: Some Mixed Salad19. B: Generator Functions ● Generator functions are supposed to offer an easy way to create generators ● A generator can be entered, exited and later re-entered again ● States that exist upon exiting will be saved until the generator is re-entered again function* a(){ var b = 0; while(true) { yield b++ } } a = a(); console.log(a.next().value); // 0 console.log(a.next().value); // 1 console.log(a.next().value); // 2 ● Think of methods, that can run indefinitely – but the developer can turn them on and off ● In a security context, generators are particularly interesting because of their constructor ● Let's have a look!21. B: AngularJS Sandbox Bypass ● AngularJS features a fairly strong sandbox ● Its purpose is to remove access to the actual DOM from within a template expression ● A secondary purpose is to mitigate negative consequences of an expression XSS (a.k.a expression interpolation, not the CSS-thing) ● This sandbox has been broken numerous times ● And repaired numerous times as well ● Although the AngularJS team says it's not a security sandbox, it is often treated as such ● Now, one check this sandbox does is to prohibit access to the Function constructor, an eval sink. ● They do so by checking if obj === obj.constructor is true ● If that is true, we have access to the Function constructor and execution stops with an error message ● ES6 bypasses this check elegantly24. C: Unicode Escapes ● Contrary to most other browsers as of now, MSIE 11 Tech Preview supports Unicode Code Points ● They have been around in earlier JavaScript versions already – but now they are different ● var a = 'ud842udf9f'; /* versus */ var b = 'u{20b9f}' ● Reason for that is of course Emoji again. Kidding. Not. ● Unicode escape sequences only allow for 65535 characters ● ES6 Unicode escapes however allow much more ● Here's an example ● The olden days: u0061lert(1) ● The ES6 way: u{0061}lert(1) or u{61}lert(1) ● Note however that this is unlikely to work in other browsers ● From our interpretation, it's against the specification ● And other parsers throw errors ● traceured.js:1:3: Hex digit expected,traceured.js:1:1: Invalid unicode escape sequence in identifier,traceured.js:1:1:25. D: Template Strings ● Now this is an actual major change ● Template strings or quasi literals allow for doing multiple things at the same time ● These are ● Applying a function to a string ● Delimit multi-line strings ● Evaluate nested inside a string ● Template strings are enclosed by the back-tick ● Which is a character that is novel and unique to JavaScript syntax ● Well, aside from RegExp, where it returns text located left from match ● Or in String.replace() where it allows replacement patterns ● But other than that it's novel and unique :) ● Let's have a look!30. D: Attacks ● Well, template strings and quasi literals enable code execution with uncommon characters ● Everything that uses or needs to use a black-list is doomed ● Hello, WAF vendors, your product is now even more useless :) ● This includes server-side filters, client side security, JavaScript sandboxes and parsers, callback safety etc. ● Repercussions are expected to exist for many years to come ● Reminds of the legendary JSON regex bypass from Stefano Di Paola ● A regex assuming certain language capabilities ● And a software (here MSIE) providing additional features ● Thereby undermining the assumption and causing a bypass ● Still useful today, almost four years after ● Documented here http://is.gd/73qYdO34. D: Flash In-Security ● Flash files often struggle with security protections ● The attack surface is huge ● Not many native protection and filter methods ● That means, developers build their own ● In the wild, we mostly see black-lists ● People securing flashVars and scanning for nasty characters ● Very common for ExternalInterface calls ● “If it has parenthesis or equals, it must be bad” ● An Example: ● JPlayer 2.2.0 and below is vulnerable to XSS ● And that despite more or less proper protection ● Well, almost proper, they use a comprehensive blacklist ● That missed out on, well, guess what?36. D: Payload with ES6 ● That blacklist is easy to bypass ● No parenthesis allowed? ● Well, we don't need those any much longer... ● Just use template strings and backticks ● Jplayer.swf?jQuery=alert(1) // noooope ● Jplayer.swf?jQuery=alert`1` // that works :) ● Only about 100k vulnerable installations ● And those kinds of blacklists are common in the Flash universe ● Similar to PHP frameworks and other filter tools37. E: Symbols ● Well, that is one weird feature out there ● Hard to describe in one sentence ● We essentially see three different use cases ● For one, as MDN puts it: – “A symbol is a unique and immutable data type and may be used as an identifier for object properties. The symbol object is an implicit object wrapper for the symbol primitive data type.” ● Then, the global symbols registry – “In contrast to Symbol(), the Symbol.for() function creates a symbol available in a global symbol registry list. Symbol.for() does also not necessarily create a new symbol on every call, but checks first if a symbol with the given key is already present in the registry.” ● And then also: – “Well-known symbols” - symbols that allow to change object properties and have magic powers. ● Now, that sounds interesting!42. E: More to Come ● The world of well-known symbols is growing ● Some of them already implemented, others not yet ● @@iterator // can we iterate over and/or spread the object? ● @@unscopable // what happens with object in with() scope ● @@hasInstance // control what happens with instanceof ● @@toPrimitive // what's returned upon implicit toString or comparable ● @@isRegExp // is the object treatable as regular expression? ● @@isConcatSpreadable // effects concat() calls and the return value ● Interesting here is the effect on DOM objects, rather than JavaScript ● Something harmless in JavaScript can have dramatic effects in the DOM ● Mozilla also supported the following syntax – extremely dangerous in combination with JSON ● Object.prototype['@@iterator']=String.prototype['@@iterator']; ● We'll have to wait for the implementation to learn more...43. F: Modules ● The include method for JavaScript ● Grab a remote file using import ● Expose an export in that remote file ● Use or execute the enclosed code ● Not part of ES6 anymore ● “For the case of scripts, the answers to this are found in the HTML Standard. For modules, the corresponding spec has not yet been written.” ● Or are they? ● Because most recent versions of the specification draft have them again ● https://people.mozilla.org/~jorendorff/es6-draft.html#sec-modules ● Soooo, not sure right now :) ● Either way, first implementations are ready for testing ● But the feature is now in standards limbo ● Let's see where it goes – because it's interesting for attackers44. F: Modules // like this import {$} from "//html5sec.org/module" // or this import{$}from 'https:html5sec.org/module' // and this import {$,} from 'https:html5sec.org/module' // or even this import*as $ from 'https://html5sec.org/module' // or this import{$ as $}from 'https:html5sec.org/module' // the actual export export function $(){} alert(1)45. G: Reflection ● ES6 brings another very important change ● This is the freshly specified Reflection API ● It allows for example for programming styles less prone to exceptions ● try{}catch(){} versus.. ● if(Reflect.doSomething()){} ● It also eliminates error sources caused by JavaScript's flexibility ● fn.apply([], [1,2,3]) // what if apply was overwritten? ● Reflect.apply(fn, [], [1,2,3]) // now we can be sure! ● Tom van Cutsem wrote an excellent text as to why Reflection is making good sense in JavaScript ● Read here https://github.com/tvcutsem/harmony-reflect/wiki ● In essence, view it as a feature that wraps around many shortcomings of ES5 and earlier editions ● With broad support of Reflection, JavaScript code will become shorter, more readable and less error prone46. G: Reflection ● In a security context, Reflection has interesting effects ● We can for example use it to set location to cause XSS ● Reflect.set(window, "location", "javascript:alert(1)") ● Reflect.set( document.body, "innerHTML", "<svg onload=alert(1)>" ) ● Or to construct ● Reflect.construct(Reflect.construct(Function, "alert(1)")) ● Sandbox Bypasses likely with Reflection ● Similarities to Java and its Reflection API security bugs? ● Only implementation so far by IE Tech Preview ● Interesting to see, if get() operations are suitable for side channels ● Getting cross-origin properties via Reflect.get() maybe? ● Potential timing differences and side channels? ● We have to wait for more vendors to implement48. Conclusion ● In short words, ES6 changes a lot ● We have seen some new features but definitely not all of them ● We essentially filtered for obvious security relevance. There might be more! ● And adds attractive features for penetration testers ● The attack surface has grown, testers now have ● Additional ways to execute code ● No need for parenthesis to execute methods ● Change the nature of objects across origins ● Execute code in areas that didn't allow that before ● Have new native objects that allow evaluation ● Have a range of tools to bypass XSS filters ● Have another range of tools to bypass JavaScript sandboxes ● The inevitable mix of DOM and ES6 causes additional trouble ● And ES7 is not too far away either ● Keep visiting the ES6 compat table, changes are frequent!